# Django моделі

Наразі ми б хотіли створити щось, що вміє зберігати усі пости в нашому блозі. Але щоб бути спроможними це зробити, нам необхідно трохи поговорити про таке поняття, як `objects` (об'єкти).

## Об'єкти

Існує така концепція в програмуванні, яка називається `об'єктно-орієнтовне програмування`. Ідея полягає в тому, що замість написання нудної послідовності програмних інструкцій ми можемо моделювати речі і визначати як вони будуть взаємодіяти одна з одною. 

Отже, що ж таке об'єкт? Це набір властивостей та дій. Звучить дивно, але ми надамо приклад.

Якщо ми хочемо змоделювати кота, то створимо об'єкт `Cat`, що має деякі властивості, наприклад, - колір `color`, вік `age`, настрій `mood` (гарний, поганий, сонний ;)), власник `owner` (це буде об'єкт `Person` або, можливо, у випадку бездомного кота, ця властивість може бути пустою).

Кіт `Cat` має певний набір дій, наприклад, муркотіти `purr`, шкрябатися `scratch`, їсти `feed` (де ми будемо давати коту певний котячий корм `CatFood`, котрий міг би бути окремим об'єктом та мати свої властивості, наприклад, смак `taste`).

    Cat
    --------
    color
    age
    mood
    owner
    purr()
    scratch()
    feed(cat_food)
    

    CatFood
    --------
    taste
    

Отже, основна ідея полягає в тому, щоб описати реальні речі в програмному коді з усіма їх властивостями (так званими властивостями об'єкта `object properties`) і діями (так званими методами `methods`).

Як же ми тоді змоделюємо пости у блозі? Ми ж хочемо створити блог, правда?

Нам треба відповісти на питання: що таке пост у блозі? Які властивості він повинен мати?

Однозначно наш допис повинен містити певний текст із змістом і заголовком, правда ж? Було б також непогано знати хто його написав, отже нам потрібен автор. Зрештою, ми б хотіли знати коли було створено і опубліковано цей допис.

    Post
    --------
    title
    text
    author
    created_date
    published_date
    

Якого роду дії можна було б вчиняти з постом у блозі? Було б непогано мати певний метод, що публікує пост, правда ж? 

Отже, нам потрібен метод `publish`.

Таким чином, знаючи нарешті, чого ми хочемо досягти, можемо почати моделювати це в Django!

## Django модель

Знаючи яким є наш об'єкт, можемо створити Django модель для постів у нашому блозі.

Модель в Django - це спеціальний вид об'єкту, який зберігається в базі даних. База даних є набором певних даних. Це є місце, де ви будете зберігати інформацію про користувачів, дописи у вашому блозі тощо. Надалі для зберігання наших даних будемо використовувати базу даних SQLite. Це база даних, що встановлена в Django за замовчуванням і, цього буде наразі для нас достатньо. 

Ви можете уявляти модель в базі даних як таблицю зі стовпчиками (полями) та рядками (дані). 

### Створення додатку

Щоб підтримувати все у порядку, створимо окремий додаток всередині нашого проекту. Дуже добре зберігати в усьому організованість з самого початку. Щоб створити додаток треба запустити наступну команду в консолі (з директорії `djangogirls`, де знаходиться файл `manage.py`):

{% filename %}Mac OS X або Linux:{% endfilename %}

    (myvenv) ~/djangogirls$ python manage.py startapp blog
    

{% filename %}Windows:{% endfilename %}

    (myvenv) C:\Users\Name\djangogirls> python manage.py startapp blog
    

Ви побачите, що була створена нова директорія `blog`, яка містить певну кількість файлів. Директорії та файли в нашому проекті мають виглядати наступним чином:

    djangogirls
    ├── blog
    │   ├── admin.py
    │   ├── apps.py
    │   ├── __init__.py
    │   ├── migrations
    │   │   └── __init__.py
    │   ├── models.py
    │   ├── tests.py
    │   └── views.py
    ├── db.sqlite3
    ├── manage.py
    ├── mysite
    │   ├── asgi.py
    │   ├── __init__.py
    │   ├── settings.py
    │   ├── urls.py
    │   └── wsgi.py
    ├── myvenv
    │   └── ...
    └── requirements.txt
    
    

Після створення застосунку, ми також повинні повідомити Django, що він має використовувати його. Ми робимо це у файлі `mysite/settings.py` - відкрийте його в редакторі коду. We need to find `INSTALLED_APPS` and add a line containing `'blog',` just above `]`. Таким чином, остаточний результат повинен мати наступний вигляд:

{% filename %}mysite/settings.py{% endfilename %}

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog',
]
```

### Створення моделі поста у блозі

У файлі `blog/models.py` ми визначаємо всі об'єкти, що називаються моделями - `Models`. Це і є місце, де ми будемо визначати наш пост. 

Відкриємо `blog/models.py` в редакторі коду, видалім усе з нього, і запишемо наступний код:

{% filename %}blog/models.py{% endfilename %}

```python
from django.conf import settings
from django.db import models
from django.utils import timezone


class Post(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    text = models.TextField()
    created_date = models.DateTimeField(default=timezone.now)
    published_date = models.DateTimeField(blank=True, null=True)

    def publish(self):
        self.published_date = timezone.now()
        self.save()

    def __str__(self):
        return self.title
```

> Переконайтесь, що ви використовуєте два символи підкреслення (`_`) з кожного боку `str`. Ця домовленість часто використовується в Python й іноді ми називаємо її "dunder" (скорочення від англ. "double-underscore").

Страхіття якесь, правда ж? Але не хвилюйтесь, ми пояснимо, що означають ці рядки!

Усі рядки, що починаються з `from` або `import` - це рядки, які додають деяку інформацію з інших файлів. Отже замість того, щоб копіювати і вставляти одне й те ж в кожному файлі,ми можемо включити деякі частини з `from ... import ...`.

`class Post(models.Model):` – цей рядок визначає нашу модуль( це об'єкт `object`).

- `class` - це спеціальне ключове слово, яке показує що ми визначаємо об'єкт.
- `Post` - це ім'я нашої моделі. Ми можемо дати інше ім'я (але ми повинні уникати використання спеціальних символів та пробілів). Завжди починайте ім'я класу із великої літери.
- `models.Model` означає, що Post це Django модель, отже Django знає, що вона повинна бути збережена у базі даних.

А зараз визначимо властивості, про які ми говорили перед цим: заголовок `title`, текст `text`, дата створення `created_date`, дата публікації `published_date` і автор `author`. Щоб це зробити нам необхідно визначити тип поля (Чи це текст? Число? Дата? Зв'язок із іншим об'єктом, наприклад, об'єктом користувача - User?). 

- `models.CharField` - це спосіб визначення тексту з обмеженою кількістю символів.
- `models.TextField` - великі блоки тексту без обмеження по розміру. Ідеально підходить для запису блогу, правильно?
- `models.DateTimeField` - це для дати та часу.
- `models.ForeignKey` - це посилання на іншу модель.

Не будемо пояснювати увесь код, оскільки це може зайняти надто багато часу. You should take a look at Django's documentation if you want to know more about Model fields and how to define things other than those described above (https://docs.djangoproject.com/en/3.2/ref/models/fields/#field-types).

А як щодо `def publish(self):`? Це і є наш метод `publish`, про який ми говорили раніше. `def` означає, що це функція/метод, а `publish` - ім'я методу. Ви можете змінити ім'я методу, якщо захочете. Правило іменування: треба використовувати рядкові букви, а пробіли замінювати нижніми підкресленнями. Наприклад, метод для розрахунку середньої ціни може бути названий `calculate_average_price`.

Методи часто `return` (повертають) щось. Приклад цього можна побачити в методі `__str__`. У цьому сценарії, коли ми викликаємо `__str__()`, то отримуємо текст (**string**) із заголовком посту.

Також зверніть увагу, що обидва метода `def publish(self):` і `def __str__(self):` відносяться до одного класу. Оскільки Python чутливий до пробілів, нам потрібно контролювати відступ наших методів всередині класу. В іншому випадку методи не будуть належати до класу, і ви можете отримати непередбачувану поведінку.

Якщо вам щось незрозуміло з приводу моделей, не соромтеся запитувати у вашого тренера! Ми знаємо, що це дуже складно, особливо коли ви одночасно вивчаєте об'єкти і функції. Але сподіваємося наразі це виглядає трохи менш таємничим для вас!

### Створення таблиць для моделей в базі даних

Останній крок - додати нашу нову модель до нашої бази даних. Спочатку потрібно повідомити Django, що змінилась наша модель (Ми щойно створили її!) Перейдіть до вашої консолі і наберіть `python manage.py makemigrations blog`. Це буде виглядати так:

{% filename %}command-line{% endfilename %}

    (myvenv) ~/djangogirls$ python manage.py makemigrations blog
    Migrations for 'blog':
      blog/migrations/0001_initial.py
    
        - Create model Post
    

**Примітка:** Не забудьте зберегати змінені файли. В іншому випадку ваш комп'ютер виконуватиме попередню версію, що може призвести до неочікуваних повідомлень про помилки.

Django підготував для нас файл з міграцією, який ми повинні тепер застосувати до нашої бази даних. Наберіть `python manage.py migrate blog`, на виході отримаємо:

{% filename %}command-line{% endfilename %}

    (myvenv) ~/djangogirls$ python manage.py migrate blog
    Operations to perform:
      Apply all migrations: blog
    Running migrations:
      Applying blog.0001_initial... OK
    

Ура! Наша модель допису Post тепер знаходиться у нашій базі даних. Було б добре побачити її, правда ж? Для цього перейдемо до наступного розділу!